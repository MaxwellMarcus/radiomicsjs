var _a;
import createWebWorkerPromise from '../core/internal/createWebWorkerPromise.js';
import WorkerPool from '../core/WorkerPool.js';
import stackImages from '../core/stackImages.js';
import InterfaceTypes from '../core/InterfaceTypes.js';
import config from '../itkConfig.js';
const workerFunction = async (webWorker, fileDescriptions, singleSortedSeries = false) => {
    let worker = webWorker;
    const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise('pipeline', worker);
    worker = usedWorker;
    const args = ['--memory-io', '--output-image', '0', '--input-images'];
    fileDescriptions.forEach((desc) => {
        args.push(`./${desc.path}`);
    });
    if (singleSortedSeries) {
        args.push('--single-sorted-series');
    }
    const outputs = [
        { type: InterfaceTypes.Image }
    ];
    const inputs = fileDescriptions.map((fd) => {
        return { type: InterfaceTypes.BinaryFile, data: fd };
    });
    const transferables = fileDescriptions.map(description => {
        return description.data.buffer;
    });
    const message = {
        operation: 'readDICOMImageSeries',
        config: config,
        fileDescriptions: fileDescriptions,
        singleSortedSeries,
        pipelinePath: 'ReadDICOMImageFileSeries',
        args,
        outputs,
        inputs
    };
    const result = await webworkerPromise.postMessage(message, transferables);
    return { image: result.outputs[0].data, webWorker: worker };
};
const numberOfWorkers = typeof ((_a = globalThis.navigator) === null || _a === void 0 ? void 0 : _a.hardwareConcurrency) === 'number' ? globalThis.navigator.hardwareConcurrency : 4;
const workerPool = new WorkerPool(numberOfWorkers, workerFunction);
const seriesBlockSize = 8;
const readImageDICOMArrayBufferSeries = async (arrayBuffers, singleSortedSeries = false) => {
    const fileDescriptions = arrayBuffers.map((ab, index) => {
        return { path: `${index}.dcm`, data: new Uint8Array(ab) };
    });
    if (singleSortedSeries) {
        const taskArgsArray = [];
        for (let index = 0; index < fileDescriptions.length; index += seriesBlockSize) {
            const block = fileDescriptions.slice(index, index + seriesBlockSize);
            taskArgsArray.push([block, singleSortedSeries]);
        }
        const results = await workerPool.runTasks(taskArgsArray).promise;
        const images = results.map((result) => result.image);
        const stacked = stackImages(images);
        return { image: stacked, webWorkerPool: workerPool };
    }
    else {
        const taskArgsArray = [[fileDescriptions, singleSortedSeries]];
        const results = await workerPool.runTasks(taskArgsArray).promise;
        return { image: results[0].image, webWorkerPool: workerPool };
    }
};
export default readImageDICOMArrayBufferSeries;
